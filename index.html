<!doctype html>
<html lang="en">
  <head>
    <title>FOUC Demo - Baseline</title>
    <meta charset="UTF-8" />
    <meta
      name="description"
      content="Baseline FOUC demo showing unstyled custom elements before definitions load."
    />
    <meta name="viewport" content="width=device-width" />
    <link rel="stylesheet" href="styles.css" />
    <script type="module" src="./scripts/components.js"></script>
    <script type="module" src="./scripts/main.js"></script>
  </head>
  <body>
    <header>
      <h1>Baseline FOUC Demo</h1>
    </header>

    <app-breadcrumbs class="breadcrumbs">
      <a href="#">Home</a>
      <a href="#">FOUC with Custom Elements</a>
    </app-breadcrumbs>

    <main>
      <aside>
        <nav-menu></nav-menu>
      </aside>

      <div class="content">
        <h2>FOUC in the Wild</h2>
        <p>
          This baseline page intentionally shows the flash of unstyled content that can happen when custom elements render before their definitions and styles arrive.
        </p>
        <section style="margin-top: 2rem">
          <h3>What's the Deal with FOUC?</h3>
          <p>
            When you use custom elements, there's a race condition between HTML parsing, JavaScript execution, and style application. Sometimes the browser renders your custom element before it's been defined, resulting in that ugly, fleeting moment of "what is this nonsense on my screen?"
          </p>
          <p>
            This site explores different strategies to minimize or eliminate FOUC on initial page load. Use the menu to compare approaches side by side.
          </p>
        </section>

        <section style="margin-top: 2rem">
          <h3>About This Page</h3>
          <p>
            <strong>Fair warning:</strong> This page does <em>not</em> use FOUC prevention logic. In fact, the component definitions in this demo have been <em>deliberately delayed</em> to emphasize the FOUC in action.
          </p>
          <p>
            Check the other pages via the navigation menu to see how we can prevent this mess.
          </p>
        </section>

        <section style="margin-top: 2rem">
          <h3>Navigation</h3>
          <p>
            Use the menu on the left to explore the different approaches:
          </p>
          <ul>
            <li><strong>With FOUC (current):</strong> The baseline problem</li>
            <li><strong>Old CSS Solution:</strong> The classic <code>:not(:defined)</code> visibility trick</li>
            <li><strong>JS Solution:</strong> Wait for definitions with a timeout fallback</li>
            <li><strong>CSS Solution:</strong> Modern CSS timeout with <code>:has()</code> + <code>@property</code></li>
          </ul>
        </section>

        <section style="margin-top: 2rem">
          <h3>The Goal</h3>
          <p>
            By the end of this experience, you'll understand why preventing FOUC matters for user experience and have concrete strategies to apply in your own projects. Plus, you'll have a newfound appreciation for the word "rendering."
          </p>
        </section>
      </div>
    </main>

    <footer>
      <p style="margin: 0">
        Â© 2026 Layout Component Demo. All rights reserved.
      </p>
    </footer>
  </body>
</html>
